{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf370
{\fonttbl\f0\fnil\fcharset0 TrebuchetMS;\f1\froman\fcharset0 Times-Roman;\f2\fswiss\fcharset0 ArialMT;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl480

\f0\fs42 \cf0 Analysis Shipping Language Support
\f1\b\fs48 \
\pard\pardeftab720\sl340

\f2\b0\fs30 \cf0 The co-location of analysis functions with storage can be used reduce power and run-time costs by exploiting parallelism within the storage system and reducing data communication. However, the common approach of shipping black-box functions (e.g. Java and Python functions) forces the storage system to apply coarse-grained control mechanisms when allocating resources such as I/O, CPU, and bandwidth, forcing the system to make worst-case estimates to achieve performance isolation. A trade-off should be made between the generality of the language used for analysis shipping, and the amount of semantic information that can be extracted at run-time to manage performance.
\f1\fs24 \
\pard\pardeftab720\sl380

\f0\b\fs34 \cf0 \
Problem
\f1\fs36 \
\pard\pardeftab720\sl340

\f2\b0\fs30 \cf0 The general approach to analysis shipping is to evaluate an arbitrary function at a remote resource. For instance, a user may request that an analysis function F() be ran on a storage node N1. The execution environment for F() is available on N1, and the storage node observes a set of requests that are emitted from F() as it executes, and inserted into the I/O queue the same as any other I/O request.
\f1\fs24 \
\pard\pardeftab720
\cf0 \
\pard\pardeftab720\sl340

\f2\fs30 \cf0 How can a storage node compare the function F() to another function F2() in terms of its I/O, CPU, or memory costs? It can observe instantaneous costs, as well as accept user-supplied information determined offline. Neither approach is robust.
\f1\fs24 \
\pard\pardeftab720\sl380

\f0\b\fs34 \cf0 \
Solution
\f1\fs36 \
\pard\pardeftab720\sl340

\f2\b0\fs30 \cf0 A two-level approach is needed in which a specialized domain-specific language (e.g. declarative language) is used to express coarse-grained properties of an analysis function which are critical to optimizing resource usage. Traditional procedural languages can be used above this layer to provide the application-specific functionality, such as distinguishing between multiple analysis kernels.
\f1\fs24 \
}